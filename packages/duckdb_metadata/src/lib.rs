use bytemuck::{Pod, Zeroable};
use gimli::leb128;
use std::io;
use thiserror::Error;

#[repr(C)]
#[derive(Clone, Copy, Pod, Zeroable)]
pub struct MetadataFields {
    pub meta_8: [u8; 32],
    pub meta_7: [u8; 32],
    pub meta_6: [u8; 32],
    pub meta_5: [u8; 32],
    pub extension_version: [u8; 32],
    pub duckdb_version: [u8; 32],
    pub platform: [u8; 32],
    pub metadata_version: [u8; 32],
    pub signature: [u8; 256],
}

impl MetadataFields {
    pub fn write(&self, mut write: impl io::Write) -> io::Result<()> {
        let metadata_fields_size = std::mem::size_of::<MetadataFields>();

        let mut metadata_field_section_bytes = [0u8; 10];
        let metadata_fields_section_len = leb128::write::unsigned(
            &mut { &mut metadata_field_section_bytes[..] },
            metadata_fields_size as u64,
        )
        .unwrap();
        let metadata_fields_section_len_bytes =
            &metadata_field_section_bytes[0..metadata_fields_section_len];

        let custom_section_name = b"duckdb_signature";

        let mut custom_section_name_bytes = [0u8; 10];
        let custom_section_name_len = leb128::write::unsigned(
            &mut { &mut custom_section_name_bytes[..] },
            custom_section_name.len() as u64,
        )
        .unwrap();
        let custom_section_name_len_bytes = &custom_section_name_bytes[..custom_section_name_len];

        let metadata_fields_size = custom_section_name_len_bytes.len()
            + custom_section_name.len()
            + metadata_fields_section_len_bytes.len()
            + metadata_fields_size;

        write.write_all(&[0])?;

        {
            let mut bytes = [0u8; 10];
            let len = leb128::write::unsigned(&mut { &mut bytes[..] }, metadata_fields_size as u64)
                .unwrap();
            let length_bytes = &bytes[0..len];

            write.write_all(length_bytes)?;
        }

        write.write_all(custom_section_name_len_bytes)?;
        write.write_all(custom_section_name)?;

        write.write_all(metadata_fields_section_len_bytes)?;

        let metadata_bytes = bytemuck::bytes_of(self);
        write.write_all(metadata_bytes)?;

        Ok(())
    }
}

#[derive(Error, Debug)]
#[error("input too long")]
pub struct InputTooLongError;

pub fn pad_32(bytes: &[u8]) -> Result<[u8; 32], InputTooLongError> {
    let mut result = [0u8; 32];
    if bytes.len() > result.len() {
        return Err(InputTooLongError);
    }

    let copy_len = bytes.len();
    result[..copy_len].copy_from_slice(&bytes[..copy_len]);
    Ok(result)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Cursor;

    #[test]
    fn test_create_metadata_section() -> Result<(), InputTooLongError> {
        // tail of http://welsch.lu/duckdb/prql/v0.0.19/v1.0.0/osx_arm64/prql.duckdb_extension.gz
        let expected: [u8; 0x216] = [
            0x00, 0x93, 0x04, 0x10, 0x64, 0x75, 0x63, 0x6B, 0x64, 0x62, 0x5F, 0x73, 0x69, 0x67,
            0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x80, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x30, 0x2E, 0x30,
            0x2E, 0x31, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x76, 0x31, 0x2E, 0x30, 0x2E, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x6F, 0x73, 0x78, 0x5F, 0x61, 0x72, 0x6D, 0x36, 0x34, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ];

        let args = MetadataFields {
            meta_8: [0; 32],
            meta_7: [0; 32],
            meta_6: [0; 32],
            meta_5: [0; 32],
            extension_version: pad_32(b"v0.0.19")?,
            duckdb_version: pad_32(b"v1.0.0")?,
            platform: pad_32(b"osx_arm64")?,
            metadata_version: pad_32(b"4")?,
            signature: [0; 256],
        };

        let mut buffer = Cursor::new(Vec::new());
        args.write(&mut buffer).unwrap();

        let result = buffer.into_inner();

        assert_eq!(result, &expected);

        Ok(())
    }
}
